# 1로 만들기 2

- 링크: https://www.acmicpc.net/problem/12852
- 난이도: Silver 1

## 문제

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

- X가 3으로 나누어 떨어지면, 3으로 나눈다.
- X가 2로 나누어 떨어지면, 2로 나눈다.
- 1을 뺀다.


정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다.  
연산을 사용하는 횟수의 최솟값을 출력하시오.

## 입력
첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 자연수 N이 주어진다.

## 출력
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.  
둘째 줄에는 N을 1로 만드는 방법에 포함되어 있는 수를 공백으로 구분해서 순서대로 출력한다.  
정답이 여러 가지인 경우에는 아무거나 출력한다.

### 예제1

```
입력: 2
출력:
1
2 1
```

### 예제2

```
입력: 10
출력:
3
10 9 3 1
```

## 풀어보기

분명 1로 만들기 문제와 같은 건 알겠는데,,  
포함되는 수를 구하는 부분에서 막혔다..  
경로 복원 문제이기 때문에 2차원을 사용해야 함을 알 수 있다.

```python
n = int(input())
dp = [[0, []] for _ in range(n+1)]
dp[1][0] = 0
dp[1][1] = [1]

for i in range(2, n+1):
    dp[i][0] = dp[i-1][0] + 1
    dp[i][1] = dp[i-1][1] + [i]
    if i % 3 == 0 and dp[i // 3][0] + 1 < dp[i][0]:
        dp[i][0] = dp[i // 3][0] + 1
        dp[i][1] = dp[i // 3][1] + [i]
    if i % 2 == 0 and dp[i // 2][0] + 1 < dp[i][0]:
        dp[i][0] = dp[i // 2][0] + 1
        dp[i][1] = dp[i // 2][1] + [i]

print(dp[n][0])
print(*dp[n][1][::-1])
```

답을 보면 재밌는데,  
풀 때는 답처럼 작성이 잘 안 되는 것 같다ㅜ  
dp 문제는 전반적으로 다시 풀어봐야 할 것으로 보인다,,
